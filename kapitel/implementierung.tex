\section{Implementierung}

In diesem Kapitel wird die Implementierung der BC Middleware auf der SAP \gls{btp} dokumentiert. Die Umsetzung folgt den in Kapitel~4 beschriebenen Architekturprinzipien und nutzt die in Kapitel~2 vorgestellten Technologien. Der Quellcode ist in einem Git-Repository versioniert und folgt etablierten Entwicklungspraktiken \citep{sommerville2015}.

\subsection{Projektstruktur}

Die Middleware folgt der Standard-Projektstruktur des SAP \gls{cap}, wie in Auflistung~\ref{lst:project-structure} dargestellt:

\begin{lstlisting}[caption={Projektstruktur}, label={lst:project-structure}]
bc_middleware/
  srv/
    budget-service.cds    # CDS Service Definition
    budget-service.js     # Service Implementation
    index.html            # API-Dokumentation
    lib/
      excel-parser.js     # Excel Adapter
      ms-auth.js          # Microsoft Graph Auth
      sharepoint.js       # SharePoint Integration
  excel_templates/
    Projekt_1/
      Budgetcontrolling.xlsx
  package.json
  manifest.yaml           # CF Deployment Config
\end{lstlisting}

\subsection{CDS Service-Definition}

Die Service-Definition in \gls{cds} beschreibt alle Entitäten, Funktionen und Actions der \gls{api}.

\begin{lstlisting}[caption={Auszug aus budget-service.cds}, label={lst:cds-service}]
service BudgetService @(path: '/api/budget') {

    @cds.persistence.skip
    entity PSPElements {
        key psp        : String(50);
            name       : String(200);
            team       : String(100);
            budgetPT   : Decimal(15, 2);
    }

    @cds.persistence.skip
    entity BudgetOverview {
        key team      : String(100);
            budgetPT  : Decimal(15, 2);
            actualPT  : Decimal(15, 2);
            etcPT     : Decimal(15, 2);
            eacPT     : Decimal(15, 2);
    }

    function getProjects() returns array of String;

    action startSession(project : String) returns {
        success   : Boolean;
        sessionId : String;
        project   : String;
    };
}
\end{lstlisting}

Die Annotation \texttt{@cds.persistence.skip} signalisiert, dass die Entitäten nicht in einer Datenbank persistiert werden, sondern zur Laufzeit aus den Excel-Daten generiert werden.

\subsection{Excel-Adapter}

Der Excel-Adapter ist das Herzstück der aktuellen Backend-Implementierung. Er nutzt die \texttt{xlsx}-Bibliothek (SheetJS) zum Parsen und Schreiben von Excel-Dateien \citep{sheetjs2024}. Die Bibliothek unterstützt verschiedene Formate (XLSX, XLS, CSV) und ermöglicht sowohl lesenden als auch schreibenden Zugriff. Die Wahl einer JavaScript-Bibliothek für die Excel-Verarbeitung folgt dem Paradigma, die gesamte Server-Logik in einer einzigen Laufzeitumgebung zu halten \citep{nodejs2024}.

\subsubsection{Datenextraktion}

\begin{lstlisting}[caption={Excel-Parser Hauptfunktion}, label={lst:excel-parser}]
function loadNewStructure(excelPath) {
    const workbook = XLSX.readFile(excelPath);

    return {
        teams: parseTeams(workbook),
        timeboxes: parseTimeboxes(workbook),
        pspElements: parsePSPElements(workbook),
        userStories: parseUserStories(workbook),
        timeBookings: parseCADO(workbook),
        pspZuordnungen: parsePSPZuordnung(workbook),
        // ... weitere Daten
    };
}
\end{lstlisting}

\subsubsection{Sheet-Parsing}

Jedes Sheet wird individuell geparst und auf das einheitliche Datenmodell gemappt:

\begin{lstlisting}[caption={Parsing der PSP-Elemente}, label={lst:parse-psp}]
function parsePSPElements(workbook) {
    const sheet = workbook.Sheets['PSP-Elemente'];
    const data = XLSX.utils.sheet_to_json(sheet, { header: 1 });

    return data.slice(1).map(row => ({
        psp: row[0]?.toString() || '',
        name: row[1]?.toString() || '',
        pspElement: row[2]?.toString() || '',
        team: row[3]?.toString() || '',
        budgetPT: parseFloat(row[4]) || 0
    }));
}
\end{lstlisting}

\subsubsection{Write-Back für PSP-Zuordnungen}

\gls{crud}-Operationen für \gls{psp}-Zuordnungen werden direkt in die Excel-Datei geschrieben:

\begin{lstlisting}[caption={PSP-Zuordnung hinzufügen}, label={lst:add-assignment}]
function addPSPAssignment(excelPath, assignment) {
    const workbook = XLSX.readFile(excelPath);
    const sheet = workbook.Sheets['1. PSP-Zuordnung'];

    // Letzte Zeile finden und neue Zeile hinzufuegen
    const range = XLSX.utils.decode_range(sheet['!ref']);
    const newRow = range.e.r + 1;

    // Werte schreiben
    sheet[XLSX.utils.encode_cell({r: newRow, c: 0})] =
        { t: 's', v: assignment.userStory };
    // ... weitere Spalten

    XLSX.writeFile(workbook, excelPath);
}
\end{lstlisting}

\subsection{Budget-Metriken Berechnung}

Die Budget-Metriken werden zur Laufzeit aus den geladenen Daten berechnet.

\subsubsection{Budget pro Team}

\begin{lstlisting}[caption={Budget-Berechnung pro Team}, label={lst:budget-calc}]
function calculateBudgetByTeam(pspElemente) {
    const budgetByTeam = {};

    for (const elem of pspElemente) {
        const team = elem.team || '(Leer)';
        if (!budgetByTeam[team]) budgetByTeam[team] = 0;
        budgetByTeam[team] += elem.budgetPT || 0;
    }

    return budgetByTeam;
}
\end{lstlisting}

\subsubsection{ETC-Berechnung}

Die \gls{etc}-Berechnung berücksichtigt nur User Stories mit gültiger \gls{psp}-Zuordnung:

\begin{lstlisting}[caption={ETC-Berechnung}, label={lst:etc-calc}]
function calculateEtcByTeam(userStories) {
    const etcByTeam = {};

    for (const story of userStories) {
        const psp = story.pspElement || '';
        // Nur Stories mit PSP-Zuordnung zaehlen
        if (!psp || psp === 'unassigned') continue;

        const team = story.team || '(Leer)';
        if (!etcByTeam[team]) etcByTeam[team] = 0;
        etcByTeam[team] += story.etcPT || 0;
    }

    return etcByTeam;
}
\end{lstlisting}

\subsection{Session-Management}

Sessions werden im Arbeitsspeicher des Servers verwaltet:

\begin{lstlisting}[caption={Session-Verwaltung}, label={lst:session-mgmt}]
const sessions = {};

function createSession(project) {
    const sessionId = crypto.randomUUID();
    sessions[sessionId] = {
        project,
        createdAt: new Date().toISOString()
    };
    return sessionId;
}

function getSession(sessionId) {
    return sessions[sessionId] || null;
}
\end{lstlisting}

\subsection{Deployment}

Die Middleware wird auf SAP \gls{btp} Cloud Foundry deployed:

\begin{lstlisting}[caption={manifest.yaml}, label={lst:manifest}]
applications:
  - name: budget-middleware
    memory: 256M
    buildpacks:
      - nodejs_buildpack
    command: npm start
    routes:
      - route: xxx-srv.cfapps.eu10.hana.ondemand.com
\end{lstlisting}

Das Deployment erfolgt mit dem Cloud Foundry CLI:

\begin{lstlisting}[caption={Deployment-Befehle}, label={lst:deploy}]
cf login -a https://api.cf.eu10.hana.ondemand.com
cf push
\end{lstlisting}

\subsection{Herausforderungen bei der Implementierung}

Während der Implementierung traten mehrere Herausforderungen auf, welche im Folgenden dokumentiert werden:

\subsubsection{Excel-Formatierung beim Schreiben}

Das Zurückschreiben in Excel-Dateien erwies sich als komplexer als ursprünglich angenommen. Die xlsx-Bibliothek unterstützt zwar das Schreiben, jedoch sind folgende Einschränkungen zu beachten: Formeln in anderen Zellen werden nicht automatisch neu berechnet, Zellenformatierungen wie Farben und Rahmen müssen explizit erhalten werden und die Power-Query-Verbindungen im Excel bleiben unberührt.

\begin{lstlisting}[caption={Erhaltung der Zellenformatierung}, label={lst:excel-format}]
function addRowPreserveFormat(sheet, rowIndex, values) {
    values.forEach((value, colIndex) => {
        const cellRef = XLSX.utils.encode_cell({
            r: rowIndex, c: colIndex
        });

        // Vorhandene Formatierung der darueberliegenden Zeile kopieren
        const templateRef = XLSX.utils.encode_cell({
            r: rowIndex - 1, c: colIndex
        });

        sheet[cellRef] = {
            t: typeof value === 'number' ? 'n' : 's',
            v: value,
            s: sheet[templateRef]?.s  // Style kopieren
        };
    });
}
\end{lstlisting}

\subsubsection{CADO-Zeitbuchungen parsen}

Die Zeitbuchungen aus dem SAP-Export (CADO-Sheet) weisen ein spezielles Format auf: Das deutsche Zahlenformat verwendet das Komma als Dezimaltrennzeichen, Datumsangaben folgen dem Format DD.MM.YYYY und PSP-Elemente enthalten Suffixe (z.B. \enquote{C72773-001.1}), die normalisiert werden müssen.

\begin{lstlisting}[caption={Parsing der CADO-Zeitbuchungen}, label={lst:cado-parse}]
function parseCADORow(row) {
    // Deutsches Zahlenformat: "2,500" -> 2.5
    const parseGermanNumber = (str) => {
        if (!str) return 0;
        return parseFloat(str.toString()
            .replace(/\./g, '')      // Tausendertrennzeichen entfernen
            .replace(',', '.'));     // Komma durch Punkt ersetzen
    };

    // PSP normalisieren: "C72773-001.1" -> "C72773-001"
    const normalizePSP = (psp) => {
        if (!psp) return '';
        return psp.toString().split('.')[0];
    };

    return {
        belegnummer: row[3]?.toString() || '',
        leistungsart: row[4]?.toString() || '',
        datum: parseGermanDate(row[5]),
        stunden: parseGermanNumber(row[6]),
        psp: normalizePSP(row[8])
    };
}
\end{lstlisting}

\subsubsection{Session-Validierung in jedem Request}

Jeder API-Request (mit Ausnahme von \texttt{getProjects} und \texttt{startSession}) erfordert eine Session-Validierung. Diese wurde als Middleware-Funktion implementiert:

\begin{lstlisting}[caption={Session-Validierung Middleware}, label={lst:session-validation}]
function requireSession(req) {
    const sessionId = req.headers['x-session-id'];

    if (!sessionId) {
        req.reject(401, 'Keine Session-ID. Header x-session-id fehlt.');
        return null;
    }

    const session = sessions[sessionId];
    if (!session) {
        req.reject(401, 'Ungueltige Session-ID. Bitte neu anmelden.');
        return null;
    }

    // Session-Timeout pruefen (8 Stunden)
    const age = Date.now() - new Date(session.createdAt).getTime();
    if (age > 8 * 60 * 60 * 1000) {
        delete sessions[sessionId];
        req.reject(401, 'Session abgelaufen. Bitte neu anmelden.');
        return null;
    }

    return session;
}
\end{lstlisting}

\subsection{API-Dokumentation}

Für die Frontend-Entwickler wurde eine interaktive API-Dokumentation erstellt, welche unter der Root-URL der Middleware erreichbar ist. Diese umfasst eine Übersicht aller Endpunkte mit Beschreibung, Request/Response-Beispiele für jeden Endpunkt, eine Erklärung der Session-Authentifizierung sowie OData Query-Optionen mit Beispielen.

\begin{figure}[H]
\centering
\fbox{\parbox{0.9\textwidth}{
\textbf{API Dokumentation - BC Middleware}\\[0.5em]
\texttt{Base URL: /api/budget}\\[1em]
\textbf{Session Endpunkte}\\
\texttt{GET /getProjects()} -- Liste verfügbarer Projekte\\
\texttt{POST /startSession} -- Session starten\\[0.5em]
\textbf{Daten Endpunkte} (benötigen x-session-id Header)\\
\texttt{GET /Teams} -- Alle Projekt-Teams\\
\texttt{GET /BudgetOverview} -- Budget-Metriken pro Team\\
...
}}
\caption{Auszug aus der API-Dokumentation (index.html)}
\label{fig:api-doc}
\end{figure}

\subsection{Testdaten}

Für Entwicklung und Test wurde ein Beispielprojekt \enquote{Projekt\_1} mit folgenden Daten angelegt:

\begin{table}[H]
\centering
\caption{Testdaten im Projekt\_1}
\label{tab:testdata}
\begin{tabularx}{\textwidth}{Xcc}
\toprule
\textbf{Entität} & \textbf{Anzahl} & \textbf{Quelle} \\
\midrule
Teams & 14 & Prüftabellen-Sheet \\
Timeboxes & 5 & Prüftabellen-Sheet \\
PSP-Elemente & 113 & PSP-Elemente-Sheet \\
User Stories & 251 & qry\_CALM\_Data-Sheet \\
Zeitbuchungen & 3.555 & CADO-Sheet \\
PSP-Zuordnungen & 4 & 1. PSP-Zuordnung-Sheet \\
\bottomrule
\end{tabularx}
\end{table}

Diese Testdaten (siehe Tabelle~\ref{tab:testdata}) ermöglichen realistische Tests aller Funktionen, einschließlich der Budget-Berechnungen und PSP-Zuordnungen. Die Datenmengen entsprechen einem typischen mittelgroßen SAP-Implementierungsprojekt.

\subsection{Qualitätssicherung durch automatisierte Tests}

Zur Sicherstellung der Softwarequalität wurde eine umfassende Test-Suite mit dem JavaScript-Testframework Jest implementiert \citep{jest2024}. Die 113 automatisierten Tests gliedern sich in Unit- und Integrationstests:

\begin{table}[H]
\centering
\caption{Übersicht der automatisierten Tests}
\label{tab:tests}
\begin{tabularx}{\textwidth}{Xcc}
\toprule
\textbf{Kategorie} & \textbf{Anzahl} & \textbf{Typ} \\
\midrule
Budget-Berechnungen & 52 & Unit \\
Session-Management & 13 & Unit \\
Excel-Parser & 9 & Unit \\
API-Endpoints & 39 & Integration \\
\midrule
\textbf{Gesamt} & \textbf{113} & \\
\bottomrule
\end{tabularx}
\end{table}

Die Budget-Berechnungslogik wurde in ein separates Modul (\texttt{budget-calculations.js}) extrahiert, um eine bessere Testbarkeit zu erreichen. Dieses Modul erreicht eine Testabdeckung von 100\,\%.

\subsubsection{Unit-Tests}

Die Unit-Tests prüfen isolierte Funktionen ohne externe Abhängigkeiten:

\begin{lstlisting}[caption={Beispiel Unit-Test für Budget-Berechnung}, label={lst:unit-test}]
describe('calculateBudgetByTeam', () => {
    it('sollte Budget pro Team korrekt aggregieren', () => {
        const pspElemente = [
            { psp: 'PSP-001', team: 'Team A', budgetPT: 100 },
            { psp: 'PSP-002', team: 'Team A', budgetPT: 50 },
            { psp: 'PSP-003', team: 'Team B', budgetPT: 200 }
        ];

        const result = calculateBudgetByTeam(pspElemente);

        expect(result['Team A']).toBe(150);
        expect(result['Team B']).toBe(200);
    });
});
\end{lstlisting}

Die Tests validieren unter anderem die korrekte Aggregation der Budget-Metriken (Budget PT, Actual PT, ETC, EAC), die Konvertierung von Stunden zu Personentagen (8h = 1 PT), die Auflösung von PSP-Suffixen (z.B. \enquote{C72773-001.1} $\rightarrow$ \enquote{C72773-001}), den Session-Lifecycle einschließlich der Timeout-Logik (8 Stunden) sowie das Parsing deutscher Zahlenformate mit dem Komma als Dezimaltrennzeichen.

\subsubsection{Integrationstests}

Die Integrationstests prüfen das Zusammenspiel der Komponenten mit realen Testdaten aus der Budgetcontrolling.xlsx:

\begin{lstlisting}[caption={Beispiel Integrationstest}, label={lst:integration-test}]
describe('GET /BudgetOverview', () => {
    it('sollte Budget-Metriken pro Team berechnen', () => {
        const pspToTeam = createPspToTeamMapping(testData.pspElemente);
        const actualByTeam = calculateActualByTeam(
            testData.timeBookings, pspToTeam
        );

        // Gesamte Actual PT sollte positiv sein
        const totalActual = Object.values(actualByTeam)
            .reduce((a, b) => a + b, 0);
        expect(totalActual).toBeGreaterThan(0);
    });
});
\end{lstlisting}

Die Tests werden mit folgenden Befehlen ausgeführt:

\begin{lstlisting}[caption={Test-Befehle}, label={lst:test-commands}]
npm test              # Alle Tests ausfuehren
npm run test:watch    # Tests im Watch-Modus
npm run test:coverage # Coverage-Report generieren
\end{lstlisting}
